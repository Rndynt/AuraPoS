# docs/replit-agent-pos-tasks.md
# Replit Agent Prompt – AuraPoS POS Tasks

You are an expert full-stack engineer (TypeScript, Node.js/Express, React, Drizzle/Neon) and an architecture-aware DDD practitioner working inside the **AuraPoS** monorepo.

Your goals:

- Follow the **task checklist below** exactly, domain by domain.
- Keep the existing DDD structure clean:
  - `apps/api` – backend
  - `apps/pos-terminal-web` – POS terminal frontend
  - `packages/domain`, `packages/application`, `packages/infrastructure`, `packages/core`, `packages/features`, `shared/`
- Do **not** introduce hard foreign-key dependencies from `orders` to restaurant-specific tables (tables, kitchen, DP, etc). Those must be separate modules that reference orders, not the other way around (except neutral fields like `table_number` string).
- The first business we optimize for is **café/restaurant**, but the design must stay generic enough for other verticals (retail, minimarket, laundry, services, PPOB).
- Authentication and external payment integrations are implemented **last**. For now we use seeded users and internal payments only.
- Every time you implement a feature:
  - Add or update relevant documentation in `/docs`.
  - Prefer small, focused commits per domain and per use case.

General implementation rules:

1. Work **top-down per domain** following the checklist; do not jump randomly unless necessary.
2. For each task:
   - Implement domain types in `packages/domain/*`.
   - Implement use cases in `packages/application/*`.
   - Implement repositories/adapters in `packages/infrastructure/*` and migrations in `shared/schema.ts` + `migrations/`.
   - Finally wire HTTP endpoints in `apps/api` and UI flows in `apps/pos-terminal-web`.
3. Keep all configuration (business type templates, module flags, etc.) in central, well-named files.
4. For temporary stubs (auth, payments, etc.), centralize them in a single place so they are easy to replace later.
5. When in doubt, choose the solution that:
   - Keeps domains decoupled.
   - Avoids leaking restaurant-only logic into generic layers.
   - Reuses existing patterns already present in the repo.

---

## AuraPoS – Domain-Based Task Checklist (EN)

> Priority: Café / Restaurant first.  
> Architecture: DDD (domain / application / infrastructure / apps/api / apps/pos-terminal-web).  
> Constraints:
> - Orders must **not** have hard foreign-key dependencies to tables, kitchen, DP, or other vertical-specific tables.
> - Business type (vertical) drives which modules/domains are loaded per tenant.
> - Authentication (AuthCore) implemented last; for now users are seeded and hardcoded from one place.
> - External payment gateways are implemented last; for now we use internal “mark as paid / partial” only.
> - Loyalty module is designed and listed, but implemented later.

### 0. Foundation & Cleanup

#### 0.1 Repo & DDD structure sanity check

- [ ] Confirm monorepo layout:
  - [ ] `apps/api` – Express backend
  - [ ] `apps/pos-terminal-web` – POS terminal web (Vite + React)
  - [ ] `packages/domain`, `packages/application`, `packages/infrastructure`, `packages/core`, `packages/features`, `shared/`
- [ ] Ensure all imports use workspace paths (`@pos/domain`, `@pos/application`, etc.).
- [ ] Remove or clearly mark legacy / unused files (if any) so Replit agent doesn’t touch them.

#### 0.2 Shared core utilities

- [ ] In `@pos/core` define shared constants & types:
  - [ ] `BusinessType` enum/union (e.g. `CAFE_RESTAURANT`, `RETAIL_MINIMARKET`, `LAUNDRY`, `SERVICE_APPOINTMENT`, `DIGITAL_PPOB`).
  - [ ] `OrderStatus`, `PaymentStatus`, `OrderTypeCode` central enums.
  - [ ] `FeatureCode` enum (sync with `tenant_features.feature_code` and `FEATURE_CODES`).

### 1. Tenant & Business Type Domain

#### 1.1 Domain model

- [ ] In `@pos/domain/tenants`:
  - [ ] Add `BusinessType` model/type.
  - [ ] Extend `Tenant` with:
    - [ ] `business_type: BusinessType`
    - [ ] `settings: Record<string, any>` (JSON config per tenant, business-type specific).
  - [ ] Add `TenantModuleConfig` type to represent which modules are enabled for a tenant:
    - [ ] Flags such as `enable_table_management`, `enable_kitchen_ticket`, `enable_loyalty`, `enable_delivery`, etc.

#### 1.2 Database schema & migrations

- [ ] Add `business_types` master table (optional but recommended):
  - [ ] `code`, `name`, `description`, `is_active`.
- [ ] Update `tenants` table:
  - [ ] Add `business_type` (FK to `business_types.code` or enum-like string).
  - [ ] Add `settings` JSON column (nullable).
- [ ] Add `tenant_module_configs` table (if you prefer explicit rows instead of JSON):
  - [ ] `tenant_id`
  - [ ] `module_code` (e.g. `TABLE_MANAGEMENT`, `LOYALTY`, `DELIVERY`)
  - [ ] `is_enabled`
  - [ ] optional `config` JSON.

#### 1.3 Application layer use cases

- [ ] `CreateTenant` use case:
  - [ ] Input includes `business_type`.
  - [ ] Creates tenant + default `tenant_features` + default `tenant_order_types` based on business type template.
  - [ ] Initializes `tenant_module_configs` or `settings` with sensible defaults.
- [ ] `GetTenantProfile` use case:
  - [ ] Returns tenant + enabled features + enabled modules for a given tenant id.

#### 1.4 Business-type templates

- [ ] Define in `@pos/application/tenants`:
  - [ ] `BusinessTypeTemplate` mapping:
    - [ ] For each `BusinessType`, list:
      - [ ] Default `order_types` to enable (e.g. Café = `DINE_IN`, `TAKE_AWAY`, `DELIVERY`).
      - [ ] Default `feature_codes` (e.g. café: `product_variants`, `kitchen_ticket`, `partial_payment`).
      - [ ] Default modules (`TABLE_MANAGEMENT` for café only, not for minimarket, etc.).
- [ ] Wire `CreateTenant` to use templates above.

#### 1.5 API / backend wiring

- [ ] Add `/api/tenants/register`:
  - [ ] Accepts `business_type`, basic tenant info.
  - [ ] Calls `CreateTenant`.
  - [ ] Returns tenant and enabled modules/features.
- [ ] Extend existing `/api/tenants/features` or create `/api/tenants/modules`:
  - [ ] Returns module flags (table management, loyalty, etc.) for front-end.

#### 1.6 Frontend integration (POS terminal)

- [ ] In `apps/pos-terminal-web`:
  - [ ] Add hook `useTenantProfile()` which:
    - [ ] Fetches tenant profile + module flags.
    - [ ] Stores `business_type` and module map in a React context.
  - [ ] Use this context to:
    - [ ] Show/hide table management screens (only for café/restaurant).
    - [ ] Show/hide delivery address fields if enabled.
    - [ ] Show/hide loyalty UI (later).

### 2. Catalog Domain (Products, Variants, Options)

> Goal: Catalog works for all verticals, but café/restaurant use-case first.

#### 2.1 Domain refinement

- [ ] In `@pos/domain/catalog`:
  - [ ] Ensure `Product` is neutral (no direct dependency on tables, kitchen, etc.).
  - [ ] Extend metadata field(s) to support different business types:
    - [ ] `metadata.service_duration_minutes` (for appointments).
    - [ ] `metadata.weight_based` / `weight_unit` (for laundry).
    - [ ] `metadata.sku_type` for PPOB vs physical goods.
- [ ] Finalize multi-modifier model:
  - [ ] `ProductOptionGroup` with `selectionType`, `min`, `max`.
  - [ ] `ProductOption` with `price_delta`, optional `inventory_sku`.

#### 2.2 Infrastructure & repository

- [ ] Ensure repositories in `@pos/infrastructure/repositories/catalog`:
  - [ ] Read/write data for products, option groups, options.
  - [ ] Always scope by `tenant_id`.
  - [ ] Support filtering by `business_type` or categories.

#### 2.3 Application use cases

- [ ] `GetProductsForTenant`:
  - [ ] Accepts `tenant_id`, optional filters.
  - [ ] Returns products including option groups/options.
- [ ] `CreateOrUpdateProduct`:
  - [ ] Handles product + variants + option groups in one operation.
- [ ] (Later) `BulkImportProducts` for retail/minimarket.

#### 2.4 POS UI integration

- [ ] Update `ProductCard` & `ProductOptionsDialog` to:
  - [ ] Support multi-modifier selection (checkbox/stepper for add-ons).
  - [ ] Validate `min`/`max` rules before adding to cart.
- [ ] Ensure café flow works:
  - [ ] Size (Small/Medium/Large).
  - [ ] Add-ons (extra shot, toppings, etc.).

### 3. Ordering Domain (Generic, No Hard Table Dependency)

> Core rule: Orders are generic.

#### 3.1 Domain model

- [ ] In `@pos/domain/orders` ensure `Order`:
  - [ ] Has `order_type_id` / `order_type_code` (DINE_IN, TAKE_AWAY, DELIVERY, WALK_IN, etc.).
  - [ ] Has `status: 'draft' | 'confirmed' | 'preparing' | 'ready' | 'completed' | 'cancelled'`.
  - [ ] Has `payment_status: 'unpaid' | 'partial' | 'paid'`.
  - [ ] Has `table_number?: string` (plain text, no FK to tables).
  - [ ] Has generic `metadata?: Record<string, any>` for business-specific extra fields.
- [ ] Keep `KitchenTicket` as separate entity referencing `order_id` (already existing).
- [ ] Keep `OrderPayment` separate (no external gateway coupling).

#### 3.2 Draft vs immediate payment flows

- [ ] In `CreateOrder` use case:
  - [ ] Create orders with `status = 'draft'` by default.
  - [ ] Allow both:
    - [ ] Draft with table: DINE_IN + `table_number`.
    - [ ] Draft takeaway: TAKE_AWAY without `table_number`.
  - [ ] `payment_status` initially `unpaid`.
- [ ] Add `ConfirmOrder` use case:
  - [ ] Moves `status` from `draft` → `confirmed`.
- [ ] Add `CompleteOrder` / `CancelOrder` use cases:
  - [ ] Complete: only allowed if fully paid OR allowed by configuration.
  - [ ] Cancel: update status, do not require payment.

#### 3.3 Order querying & listing

- [ ] Add `ListOpenOrders` use case:
  - [ ] Returns orders with status in `['draft', 'confirmed', 'preparing', 'ready']`.
  - [ ] Filter by order type and optionally by `table_number`.
- [ ] Add `ListOrderHistory` use case:
  - [ ] Paged list for completed/cancelled orders for reporting.

#### 3.4 API endpoints

- [ ] `/api/orders`:
  - [ ] `POST` – create draft order (cart→order).
  - [ ] `GET` – list orders with filters.
- [ ] `/api/orders/:id/confirm` – confirm order.
- [ ] `/api/orders/:id/complete` – complete order.
- [ ] `/api/orders/:id/cancel` – cancel order.

#### 3.5 POS UI

- [ ] Add “Order list” view:
  - [ ] Tabs/filters for dine-in drafts, takeaway drafts, ready for payment.
- [ ] When creating order from cart:
  - [ ] Dialog to select order type, optional table selection or free-text `table_number`, and option to pay immediately or save as draft.

### 4. Table & Seating Management Domain (Café/Restaurant Only)

> Implemented as separate module. Orders do not depend on tables with hard FK.

#### 4.1 Domain model

- [ ] New `@pos/domain/seating` (or `tables`) package:
  - [ ] `Table` entity with capacity and status.
  - [ ] `TableStatus` enum (`AVAILABLE`, `OCCUPIED`, `RESERVED`, `DIRTY`, `INACTIVE`).
  - [ ] `TableSession` linking `table_id` and `order_id`.

#### 4.2 Database schema

- [ ] `tables` table.
- [ ] `table_sessions` table referencing `orders.id`.

#### 4.3 Application use cases

- [ ] `CreateTable`, `UpdateTable`, `ListTables`.
- [ ] `OpenTableSession`, `MoveTableSession`, `CloseTableSession`.

#### 4.4 POS UI

- [ ] “Table view” grid for café tenants.
- [ ] Click table to open/create order as described earlier.

### 5. Kitchen & Fulfillment Domain

- [ ] Wire `CreateKitchenTicket` use case on order confirmation.
- [ ] Add `UpdateKitchenTicketStatus`.
- [ ] Implement repository + endpoints + simple kitchen UI.

### 6. Payment Domain (Internal First, Gateway Later)

- [ ] Ensure `OrderPayment` and `RecordPayment` use case support partial payments.
- [ ] Add internal refund/void use cases.
- [ ] Implement `/api/orders/:id/payments` and payment dialog in POS UI.
- [ ] Plan abstraction for external gateways (Phase 2).

### 7. Authentication & User Domain (AuthCore Last)

- [ ] Add `User` and `TenantUser` domain models and tables.
- [ ] Seed multiple tenants and users (different business types).
- [ ] Implement one centralized auth stub middleware (header-based).
- [ ] Plan replacement with AuthCore later while preserving request context interface.

### 8. Loyalty Domain (Design Now, Implement Later)

- [ ] Define `LoyaltyAccount`, `LoyaltyTransaction`, `LoyaltyRule` domain types.
- [ ] Plan tables and use cases (`AccruePointsOnOrderCompleted`, `RedeemPointsForOrder`).
- [ ] Add `LOYALTY` module flag in tenant module config.

### 9. Reporting Domain (Basic)

- [ ] Implement `GetSalesSummary` and `GetBestSellingProducts`.
- [ ] Add `/api/reports/sales-summary` and simple dashboard UI.

### 10. POS Terminal UX (Café First)

- [ ] Implement main flows (order creation, draft, kitchen, payment, complete).
- [ ] Ensure navigation tabs/pages are clear and follow tenant business type + module flags.

### 11. Documentation & DX

- [ ] Keep `/docs` updated with diagrams and explanations per domain.
- [ ] Maintain a `features_checklist.md` reflecting this checklist.
- [ ] Document seed flows and sample café tenant scenario.

---

When you finish a group of tasks for a domain, ensure:

- All tests and type checks pass.
- The feature is demo-able using the seeded café tenant.
- The implementation does not introduce unwanted coupling between domains or business-type-specific concerns and generic layers.